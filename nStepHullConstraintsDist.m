function [Constraints] = nStepHullConstraintsDist(Omega, X, U, W, N, A, B, C, alpha, x, sF, sH)
%nStepHullConstraintsDist Generates the linear constraints specifying the
%convex hull of the union of the first N backwards step sets of Omega with
%disturbance
%scaled by alpha according to Theorem 3 of Computing control invariant sets in high dimension is easy
%   Omega - initial set, seed
%   X - State space / constraints
%   U - Input space
%   W - Disturbance space
%   N - number of steps
%   A - non-singular state-transition matrix
%   B - input matrix
%   C - disturbance matrix
%   alpha - scaler found by growth LP
%   x - yalmip decision variable to be used for the point in the set
%   sF,sH - sum disturbance offsets computed by controlInvariantDistGrowthLP
%
%   The constraints generated by this function can be used to test
%   membership of a given point 'p' in the invariant set by adding the 
%   additional constraint (x == p) and optimizing over the constraints.
%
%   Omega,X,U are convex polytopes each containing the origin
%       They should have halfspace representations in MPT
%   Also this function might apply to singular A matrices without modification

%   For now ignore equality constraints in polytopes

%Linear inequality representation of polytopes X,U,Omega
F = X.A;
f = X.b;
G = U.A;
g = U.b;
H = Omega.A;
h = Omega.b;

%Dimensions of system and constraints
n = size(A,1);
m = size(B,2);

%Decision variables for feasibility LP
z = sdpvar(n,N, 'full');
v = sdpvar(m, N, N, 'full');
lambda = sdpvar(N, 1, 'full');

%Constraints for LP
Constraints = [x == sum(z, 2); lambda >= 0; sum(lambda) == 1];

for k = 1:N
    Constraints = [Constraints;
        H * stepMap(k, A, B, z(:,k), v(:, :, k)) <= alpha * lambda(k) * (h + sH / alpha);
        F * z(:,k) <= lambda(k) * f;
    ];
    for j = 1:k
        Constraints = [Constraints;
            F * stepMap(j, A, B, z(:,k), v(:,:,j)) <= lambda(k) * (f + sF(:,j+1));
            G * v(:, j, k) <= lambda(k) * g;
        ];
    end
end


end

